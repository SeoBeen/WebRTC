# 배포 

## EC2 ubuntu 서버를 이용하여 배포
<br/>

---

## Docker 설치
- 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼

<br/>

### 1. 필수 패키지 설치
```bash
sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
```

<br/>

### 2. GPG Key 인증
```bash
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
```

<br/>

### 3. docker repository 등록
```bash
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
```
     
<br/>

### 4. docker 설치
```bash
sudo apt-get update && sudo apt-get install docker-ce docker-ce-cli containerd.io
```

<br>             

## jenkins
- CI/CD 툴
- 지속적 통합 지속적 배포

<br/>

### 1. run 명령어
```bash
  sudo docker run -d --name jenkins -u root --privileged \
  
  -p '9090:8080' \
  
  -v '/home/ubuntu/docker-volume/jenkins:/var/jenkins_home' \
  
  -v '/var/run/docker.sock:/var/run/docker.sock' \
  
  -v '/usr/bin/docker:/usr/bin/docker' \
  
  jenkins/jenkins 
```

<br/>

### 2. Docker 사용 확인
```bash
  sudo docker exec -it jenkins bash
  
  docker -v
```

<br/>

### 3. Jenkins 컨테이너 내부 docker-compose 설치
```bash
  docker exec -it jenkins bash

  curl -L "https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
  
  chmod +x /usr/local/bin/docker-compose
  
  docker-compose -v
```

<br/>

### 4. Jenkins 환경 설정
```bash
  i6e202.p.ssafy.io:9090 접속
  
  sudo docker logs jenkins 명령어 입력 -> root 계정 비밀번호 확인 후 입력
  
  Install suggested plugins 선택
  
  계정 생성
```
    
<br/><br/>


## SSL 인증서 발급

<br/>

### 1. letsencrypt 설치하기
```bash
  sudo apt-get update 
  sudo apt-get install letsencrypt
```

<br/>

### 2.  인증서 발급 
```bash
  sudo letsencrypt certonly --standalone -d i6e202.p.ssafy.io
```

<br/>  

### 3. 비밀번호, 이메일 입력 및 안내 사항에 동의 후 진행  

<br/>

### 4. root 계정 로그인 
```bash
  sudo su
```

<br/>

### 5. 인증서 위치 폴더 이동 
```bash
cd /etc/letsencrypt/live/도메인
```      
- pem을 PKCS12 형식으로 변경 
```
  openssl pkcs12 -export -in fullchain.pem -inkey privkey.pem -out key.p12 -name airpageserver -CAfile chain.pem -caname root 
```

<br/>

### 6. 인증서 복사 

<br/>

### 7. 인증서 보관 폴더를 미리 생성해 주세요 
 ```bash
  sudo cp [파일이름] [인증서를 보관 할 docker volume 폴더]

  예시) 
  sudo cp fullchain.pem /home/ubuntu/docker-volume/ssl 

  sudo cp privkey.pem /home/ubuntu/docker-volume/ssl  

  sudo cp key.p12 /home/ubuntu/docker-volume/ssl
 ```
         
<br><br>

## 프론트엔드
- nginx : 배포용 경량 웹서버
- DockerFile 작성
    
```bash
  FROM node:14 as build-stage
  WORKDIR /app
  ADD . .
  RUN npm install
  RUN npm run build

  FROM nginx:stable-alpine as production-stage
  COPY  ./nginx/nginx.conf /etc/nginx/conf.d/default.conf

  COPY --from=build-stage /app/dist /usr/share/nginx/html
  CMD ["nginx", "-g", "daemon off;"]
``` 


- nginx 설정 파일 작성

```bash
  # 80 port를 openvidu에서 쓰기 때문에 9999 port 사용
  server {
  listen 9999;
  listen [::]:9999;
      
      # server_name 도메인;
  server_name i6e202.p.ssafy.io;

  access_log /var/log/nginx/access.log;
      error_log /var/log/nginx/error.log;

  location / {
      alias /usr/share/nginx/html;
      try_files $uri $uri/ /index.html;
      return 301 https://$server_name$request_uri; # http 접속 시 https 로 자동 접속
  }
  }

  server {
      listen 443 ssl;
      listen [::]:443 ssl;
      
      # server_name 도메인;
      server_name i6e202.p.ssafy.io;

      ssl_certificate /var/www/html/fullchain.pem;
      ssl_certificate_key /var/www/html/privkey.pem;

      root /usr/share/nginx/html;
      index index.html;

      location / {
          try_files $uri $uri/ /index.html;
      }
  }
```

<br/><br/>

## 백엔드

<br/>

### 배포용 application.properties 작성
1. 배포용 설정을 입력하기 위한 application-prod.properties 생성
2. 기존 설정 + SSL 설정 작성
```bash
  # application-prod.properties
  # SSL 설정

  server.port=8443
  server.ssl.enabled=true
  server.ssl.key-store-type=PKCS12
  server.ssl.key-store=/root/key.p12
  server.ssl.key-store-password=#인증서 비밀번호
```

<br/>

### Dockerfile 작성
```
  # backend/Dockerfile
  # 사용한 openjdk 버전에 맞는 값을 입력해주세요.
  FROM openjdk:8-jdk-alpine

  # jar 파일 경로는 직접 입력해주세요.
  COPY build/libs/backend-0.0.1-SNAPSHOT.jar app.jar

  # 배포용 properties 실행 명령어
  ENTRYPOINT ["java","-jar","app.jar","--spring.config.name=application-prod"] 
```

<br><br>


## 통합 docker-compose
```bash
  # 프로젝트 Root 폴더
  version: '3.2'

  services: 
  frontend:
      image: frontend-vue
      build:
      context: frontend/
      dockerfile: Dockerfile
      ports:
      - "9999:9999"
      - "443:443" 
      # [인증서 파일 저장 경로]:/var/www/html
      volumes:
      - /home/ubuntu/docker-volume/ssl:/var/www/html
      container_name: "front-end"
  
  backend:
      image: backend-spring
      build:
      context: backend/
      dockerfile: Dockerfile
      ports:
      - "8443:8443"  
          # [인증서 파일 저장 경로]:/root 
      volumes:
      - /home/ubuntu/docker-volume/ssl:/root
      container_name: "back-end"
```

<br/><br/>


## Jenkins Credential & Webhook & Pipeline

<br/>

### Credential
  1. Username / Password : Gitalb 계정
  2. ID : Credential 식별자
  3. Description : Credential 설명

<br/>

### Webhook
<br/>

1. GitLab 플러그인 설치
      ```
      Jenkins 관리 → 플러그인 관리 → 설치 가능 - GitLab 설치 및 재시작
      ```
<br/>

2. Pipeline 생성
      ```
      새로운 Item → Pipeline 
      ```
<br/>        
 
3. Jenkins - GitLab Webhooks Secret token 생성
      ```
      구성 → Build when a change is pushed to ...→ 고급 버튼→ Secret token 
      ``` 

<br/>

4. Gitlab - Webhooks 설정
      ```
      Settings - Webhooks → URL : #1 URL→ Secret token : #2 Secret token→ Add webhook → Test - Push Events → Hook executed successfully: HTTP 200확인
      ```

<br/>

5. Push events 에서 Trigger 를 발생시킬 branch로 deploy branch 설정

<br/>

6. Pipeline
      ```
      Definition - Pipeline script
      ```
        
<br/>

7. Script 입력
      ```
      node {
            stage ('clone') {
                git branch: 'deploy', credentialsId: 'credential 식별자', url: 'Gitlab 저장소 Url'
            }
            stage ('gradle build') {
                        // 팀 프로젝트 설정(백엔드 폴더 이름, 사용 배포 도구(Gradle, Maven)에 맞게 수정
                dir('back-end'){
                    sh 'chmod +x gradlew'
                    sh './gradlew build'
                } 
            }

            stage ('docker build') {
                sh 'docker-compose down --rmi all' 
                        sh 'docker-compose up -d --build' 
                        sh 'docker rmi $(docker images -f "dangling=true" -q)'
            } 
        }
      ```

<br/><br/><br/>

# OAuth 2.0

## OAuth 2.0란?
- Open Authorization 2.0, OAuth2

- 인증을 위한 개방형 표준 프로토콜

- third-Party 프로그램에게 리소스 소유자를 대신하여 리소스 서버에서 제공하는 자원에 대한 접근 권한을 위임하는 방식을 제공

- 간편 로그인 기능 구현을 위해 사용
    - 구글, 페이스북, 카카오, 네이버 등
<br/><br/>


## **OAuth 2.0 주요 용어**

| 용어 | 설명 |
| --- | --- |
| Authentication | 인증, 접근 자격이 있는지 검증하는 단계를 말합니다. |
| Authorization | 인가, 자원에 접근할 권한을 부여하는 것입니다. 인가가 완료되면 리소스 접근 권한이 담긴 Access Token이 클라이언트에게 부여됩니다 |
| Access Token | 리소스 서버에게서 리소스 소유자의 보호된 자원을 획득할 때 사용되는 만료 기간이 있는 Token입니다. |
| Refresh Token | Access Token 만료시 이를 갱신하기 위한 용도로 사용하는 Token입니다. Refresh Token은 일반적으로 Access Token보다 만료 기간이 깁니다. |


<br/><br/>

## accessToken
![oauth0](screenshot/oauth0.png)
- 아이디 / 비밀번호가 아니라서 안전
- 나의 서비스에서 꼭 필요한 기능 일부분만 이용할 수 있는 장점

<br/><br/>    

## 역할 구분
![oauth1](screenshot/oauth1.png)

### 1. **Resource Owner**
- 고객, 사용자

<br/>

### 2. **Client**
- 나의 서비스

<br/>

### 3. **Resource Server**
- 구글, 페이스북, 네이버 등 고객의 정보를 제공하는 곳

<br/>

### 4. **Authorization Server**
1. 인증 관련한 처리를  하는 서버
2. 공식 문서에는 Resource / Authorization 두 가지 서버로 나눠져 있음
3. 여기선 간단한 설명을 위해 Resource Server로 합쳐서 설명

<br/>

## Register

### 1. 사전에 승인을 받아 놓아야 한다.

<br/>

### 2. 등록하는 방법은 각 Resource Server마다 다르지만 공통적인 세가지
1. Client ID
    1. 우리가 만들고 있는 애플리케이션을 식별하는 식별자.
    2. 노출되어도 상관 없다.

<br/>

2. Client Secret
    1. 비밀번호
    2. 절대로 외부에 노출되면 안된다.

<br/>

3. Authorized redirect URLs
    1. Authorized : 권한을 부여하다.
    2. Resource Server가 권한을 부여하는 과정에서 Authorize Code를 전달해준다.
    3. 그 때 이 주소로 전달해 달라고 알려준 것.
    4. Resource Server는 다른 주소에서 요청을 하면 거부를 할 것이다.

<br/>

4. 각 Resource Server에 등록하는 방법은 생략
    1. 구글에서 검색해서 사용

<br/><br/>

## OAuth 작동 흐름

### 1. 고객의 정보를 사용하겠다는 동의가 필요하다.
- 각 Resource Server에 맞는 버튼을 클릭하는 것으로 동의를 얻는 것

<br/>

### 2. 그러면 아래와 같은 주소로 요청을 보낸다.
- scope의 경우에는 Resource Server에서 제공하는 기능 중 사용하고자 하는 기능

![oauth2](screenshot/oauth2.png)

<br/>
    
### 3. Resource Owner가 Resource Server로 요청을 보내게 되면
![oauth3](screenshot/oauth3.png)

<br/>

### 4. Resource Server는 로그인이 되어 있는지 확인하고 안되어 있으면 로그인 화면을 보낸다.
    
![oauth4](screenshot/oauth4.png)

<br/>

### 5. 이후, 로그인 후 다시 요청이 들어오면 그때서야 Client Id와 redirect URL이 같은지 확인한다.

<br/>

### 6. 다르면 종료하고, 같으면 Client에게 Scope와 같은 기능 제공하는 것을 동의하는지를 묻는 페이지를 다시 보낸다.
![oauth5](screenshot/oauth5.png)

<br/>

### 7. 동의를 하게 되면 Resource Server는 다음과 같은 user id와 제공한 기능을 저장해둔다.
![oauth6](screenshot/oauth6.png)

<br/>

### 8. 이후 Client에게 바로 accessToken을 발급하지 않고 임시 비밀번호를 발급한다.

<br/>

### 9. authorization code를 Resource Owner에게 전송한다.
1. Location : https://client/callback?code=3
2. Header에 Location 붙여서 보냄, 의미는 Redirection 
3. Resource Server가 Resource Owner 브라우저에게 위의 주소로 이동하라고 명령을 내린 것

![oauth7](screenshot/oauth7.png)

<br/>

### 10. Resource Owner의 브라우저가 Header Location의 명령에 따라 Client에게 요청을 보낸다.

![oauth8](screenshot/oauth8.png)

<br/>

### 11. 그러면 Client는 Resource Server에게 자신이 가진 4가지 정보를 보낸다
1. Client Id, Client Secret, redirect URL, authorization code
2. 이러한 [authorization code를 이용하는 방법을 포함한 4가지 방법](#토큰-발급-방식(grant-type)은-총-4가지)이 있다.

<br/>

### 12. 4가지가 모두 일치하는지 확인 후에 access Token을 발급 한다.

![oauth9](screenshot/oauth9.png)

### 13. 인증 후에 authorization code를 Client와 Resource Server에서 지운다.

<br/>

### 14. 그리고 AccessToken을 발급 해준다.

<br/>

### 15. Client가 AccessToken으로 접근을 할 때 다음과 같은 것을 보장한다.
- user id 1을 가진 사용자의  대한 정보, 유효한 기능 b, c를 accessToken 4를 가진 Client 허용

![oauth10](screenshot/oauth10.png)

<br/><br/>


## 토큰 발급 방식(grant type)은 총 4가지

- 기본적으로 헤더에 authorization 값(clientid:secretkey base64 인코딩한 값)을 넣어서 요청

<br/>

### 1. code (code를 발급받고 code로 access token 발급)

1. code 발행
    - 아래 url은 기본 oauth2.0 코드 발급 URI로 절차 완료시 redirect_uri 로 code 가 발행된다.
    - URL : http://localhost:8080/oauth/authorize
    - Parameter
        - response_type=code
        - redirect_uri=코드 전달받을 URL
        - scope=read

<br/>

2. access token 발행
    - 발급 받은 코드를 가지고 token 을 발행 한다.
    - URL : http://localhost:8080/oauth/token
    - Parameter
        - grant_type=code
        - authorization_code=발급받은코드
        - redirect_uri=코드 전달받은 URL

<br/>

### 2. password (id, pw 로 access token 발급)

- access token 발행
    - id, pw 로 토큰을 바로 발급 받을 수 있다.
    - URL : http://localhost:8080/oauth/token
    - Parameter
        - grant_type=password
        - username=아이디
        - password=패스워드
        - scope=read

<br/>

### 3. client_credentials (바로 access token 발행)

- 다른 정보를 요하지 않고 authorization 에 clientid, secret key만 등록된 정보면 바로 발행
- 그런 특성으로 정말 별다른 인증 필요 없는 신뢰도가 높은 클라이언트에게만 해당 방식을 허용
- 해당 방식은 별다른 인증을 요하지 않기에 위험성이 있어 refresh_token은 따로 발행 하지 않음
- URL : http://localhost:8080/oauth/token
- Parameter
    1. grant_type=client_credentials
    2. scope=read
    
<br/>

### 4. refresh_token (refresh token으로 access token 발행)

- 해당 방식은 1, 2번으로 인증 후 재 로그인 없이 자동 로그인을 구현하기 위함
- 1,2 방식으로 access_token 발행과 동시에 refresh_token 도 같이 발행해주기에 얻은 refresh token로 token 발행이 가능하다.
- URL : http://localhost:8080/oauth/token
- Parameter
    1. grant_type=refresh_token
    2. refresh_token=이전에 발급받은 refresh token
    3. scope=read

<br/>

## Refresh Token
1. Access Token은 수명이 있다.
    - 짧으면 몇 시간, 길게는 60일 90일 단위로 살아있다.
    - 수명이 끝나면 더 이상 API에 접속해도 데이터를 주지 않는다.

<br/>

2. 수명이 끝날 때 마다 Access Token을 다시 발급하게 하는 과정을 사용자에게 겪게 하면 불편

<br/>

3. oauth 2.0 RFC 
    - RFC는 인터넷과 관련된 여러가지 표준안
    - [https://datatracker.ietf.org/doc/html/rfc6749#section-1.5](https://datatracker.ietf.org/doc/html/rfc6749#section-1.5)

<br/>
    
![oauth11](screenshot/oauth11.png)
    
### 1. A : 권한을 획득 / 허가 한다.
<br/>

### 2. B : Access / Refresh Token 둘 다 발급 받는다.
<br/>

### 3. C : Access Token으로 인증
<br/>

### 4. D : 보호되고 있는 자원
<br/>

### 5. E : Access Token으로 인증
<br/>

### 6. F : 인증되지 않은 토큰
<br/>

### 7. G : Refresh Token으로 인증
<br/>

### 8. H : Access Token 다시 발급 받는다.
- Refresh Token도 다시 발급 되는 곳도 있다.
- **Google Doc - Refreshing an access token**
```json
// Request
POST /token HTTP/1.1
Host: oauth2.googleapis.com
Content-Type: application/x-www-form-urlencoded

client_id=your_client_id&
client_secret=your_client_secret&
refresh_token=refresh_token&
grant_type=refresh_token

// Response
{
    "access_token": "1/fFAGRNJru1FTz70BzhT3Zg",
    "expires_in": 3920,
    "scope": "https://www.googleapis.com/auth/drive.metadata.readonly",
    "token_type": "Bearer"
}
```

## 기술 구현

<br/>

## 참조한 사이트
1. https://deeplify.dev/back-end/spring/oauth2-social-login

2. https://velog.io/@swchoi0329/스프링-시큐리티와-OAuth-2.0으로-로그인-기능-구현#5-세션-정장소로-데이터베이스-사용하기

<br/>

## Front End 구현
- 요청을 보내는 URL & Redirect URL
``` html
<!-- 구글 -->
<a class="social_btn" href="https://i6e202.p.ssafy.io:8443/oauth2/authorization/google?redirect_uri=https://i6e202.p.ssafy.io/oauth/redirect"></a>

<!-- 네이버 -->
<a class="social_btn" href="https://i6e202.p.ssafy.io:8443/oauth2/authorization/naver?redirect_uri=https://i6e202.p.ssafy.io/oauth/redirect"></a>

<!-- 카카오 -->
<a class="social_btn" href="https://i6e202.p.ssafy.io:8443/oauth2/authorization/kakao?redirect_uri=https://i6e202.p.ssafy.io/oauth/redirect"></a>

```

<br/>

## Back End 구현

### 1. aplication properties, gradle 설정 내용 생략
<br/>

### 2. SecurityConfig에 요청을 받는 코드를 구현
```java
public class SecurityConfig extends WebSecurityConfigurerAdapter {
   
   ...

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http

                ...
                // 인증이 필요한 부분 구글 oauth2Login부분
                .antMatchers("/oauth2/authorization/**").authenticated() 
                .and()
                .logout()
                .logoutSuccessUrl("/")
                .and()
                .oauth2Login()
                .userInfoEndpoint()
                .userService(customOAuth2UserService)
                .and()
                .successHandler(oAuth2AuthenticationSuccessHandler)
                .failureHandler(oAuth2AuthenticationFailureHandler);
    }
}
```

<br/>

### 3. CustomOAuth2UserService 구현하여 토큰 및 회원가입 자동 처리
```java
public class CustomOAuth2UserService implements OAuth2UserService<OAuth2UserRequest, OAuth2User> {

    private final UserRepository userRepository;

    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
        OAuth2UserService delegate = new DefaultOAuth2UserService();
        OAuth2User oAuth2User = delegate.loadUser(userRequest);

        // 구글 / 네이버 / 카카오 로그인인지 구분용
        String registrationId = userRequest.getClientRegistration().getRegistrationId();

        // 제공 타입
        String userNameAttributeName = userRequest.getClientRegistration()
                .getProviderDetails().getUserInfoEndpoint().getUserNameAttributeName();
                
        // 유저 토큰
        String userToken = userRequest.getAccessToken().getTokenValue();
        
        ...

        return new DefaultOAuth2User(
                Collections.singleton(new SimpleGrantedAuthority(user.getRoleKey())),
                attributes.getAttributes(),
                attributes.getNameAttributeKey());
    }
}
```

<br/>

### 4. OAuth2AuthenticationSuccessHandler / OAuth2AuthenticationFailureHandler 구현하여 성공, 실패결과 리턴
```java
@Component
public class OAuth2AuthenticationSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

    @Autowired
    private UserRepository userRepository;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                        Authentication authentication) throws IOException {
            
        ...

        String url = makeRedirectUrl(JwtTokenUtil.getToken(user.getEmail()));

        getRedirectStrategy().sendRedirect(request, response, url);
    }

    private String makeRedirectUrl(String token) {
        return UriComponentsBuilder.fromUriString("https://i6e202.p.ssafy.io:443/oauth/success")
                .queryParam("accessToken", token)
                .build().toUriString();
    }

}
```

<br/><br/>

## Trouble Shooting

<br/>

### 오류 원인
1. Redirect가 성공하여 Token은 정상적으로 넘어갔으나 액션이 동작하지 않는 다는 페이지가 나왔다.
2. 우선 FrontEnd, BackEnd 통합 빌드 배포가 아니다.
3. FrontEnd, BackEnd 각각, Docker 컨테이너 이미지로 따로 돌아간다.
4. 서로 Port 번호가 다름
    - FronEnd : 443
    - BackEnd : 8443
5. SuccessHandler, FailureHandler에서 Redirect를 할 때 포트 번호가 달라 문제가 생겼다.


<br/>

### 해결 방법
1. SuccessHandler에 redirect하는 부분에 도메인:443/oauth/success로 직접 포트 지정
2. Failure도 같은 방식으로 바꿔, 정상적으로 동작하도록 수정


<br/><br/><br/>

# WebRTC

## WebRTC

![openvidu2](screenshot/openvidu2.png)

- 웹 애플리케이션과 사이트가 중간자 없이 브라우저 간에 오디오나 영상 미디어를 포착하고 마음대로 스트림할 뿐 아니라, 임의의 데이터도 교환할 수 있도록 하는 기술입니다.

- 구글이 오픈소스화한 프로젝트에서 기원하였으며, 그 뒤로 국제 인터넷 표준화 기구(IETF)가 프로토콜 표준화 작업을, W3C가 API 정의를 진행하였으며, 음성 통화, 영상 통화, P2P 파일 공유등으로 활용될 수 있습니다.

<br/><br/>

## OpenVidu
- WebRTC 기술을 이용해 미디어 전송을 할 수 있는 크로스 플랫폼 프레임워크로, 웹 또는 모바일 애플리케이션에서 화상통화를 쉽게 추가할 수 있는 플랫폼입니다.

- WebRTC 미디어 서버를 구현하는 데 소모되는 리소스를 절약해서 빠르게 실시간 통신을 추가할 수 있도록 도와주는 것이 큰 장점입니다.

<br/>

### Openvidu는 크게 두 파트로 나눌 수 있고 다음과 같습니다.

![openvidu1](screenshot/openvidu1.png)

### Openvidu Browser
- 클라이언트 측에서 사용할 라이브러리
- 화상 통화를 만들고, 비디오와 오디오를 주고받을 수 있게끔 도와줍니다.
- Openvidu에서 사용할 수 있는 모든 작업은 Openvidu 브라우저를 통해 관리됩니다.

<br/>

### Openvidu Server
  - 서버 측 내용을 처리하는 애플리케이션
  - Openvidu 브라우저에서 작업을 수신하고, 비디오 통화를 설정하고, 관리하는 데 필요한 모든 작업을 수행합니다.
  - 명시적으로 구현할 필요는 없고, 실행한 뒤에 접근할 수 있는 IP 주소만 알고 있으면 됩니다.

<br/><br/>

## 적용
- 늘비상담은 사용자에게 실시간 화상 통화를 통한 고민 해소 솔루션을 제공합니다.
- 이러한 이유로 웹 브라우저 간에 플러그인의 도움 없이 서로 통신할 수 있는 WebRTC를 채택하였습니다.
- 또, OpenVidu는 다양한 프레임워크 특히 Vue와의 호환성이 높기 때문에 프로젝트의 손쉬운 적용을 위해 사용하였습니다.

<br/><br/>

## Trouble Shooting
- EC2 서버에 온프로미스 방식으로 openvidu 서버 배포
- 화상 채팅 입장/채팅 기능/이모지 기능은 가능하나, 상대방의 비디오, 오디오가 출력되지 않는 상황
- Error : OpenVidu 접속 오류(CONNECT REFUSED)

<br/>

### 오류 원인: coturn 서버 문제
- OpenVidu 서버 http 포트를 변경해도 적용되지 않고, 80번 포트를 차지함. 

<br/>

### 해결 방법: http 포트 변경을 통한 해결
- 포트 이슈 해결을 위해 기존 프론트엔드가 가지고 있던 http 포트를 변경하여 해결함.


<br/><br/><br/>


# Chatting System

## Web Socket

<br/>

### Web Socket이란?

![채팅시스템_WebSocket](./screenshot/채팅시스템_WebSocket.PNG)

- 웹 서버와 웹 브라우저간 실시간 양방향 통신환경을 제공해주는 실시간 통신 기술입니다.
- HTTP와 달리 완전한 이중 통신을 사용하여 Web Socket이 TCP에서 메시지를 스트리밍 할 수 있습니다.
- 양방향으로 원할때 요청을 보낼 수 있으며 stateless한 HTTP에 비해 오버헤드가 적으므로 유용하게 사용할 수 있습니다.

<br/>

### Web Socket의 필요성

- 실시간 양방향 데이터 통신이 필요한 경우
- 많은 수의 동시 접속자를 수용해야 하는 경우
- 브라우저에서 TCP 기반의 통신으로 확장해야 하는 경우
- 개발자에게 사용하기 쉬운 API가 필요할 경우
- 클라우드 환경이나 웹을 넘어 SOA 로 확장해야 하는 경우

<br/>

### Web Socket 접속 과정
![WebSocket접속과정](./screenshot/WebSocket접속과정.png)
- 웹소켓을 이용하여 서버와 클라이언트가 통신을 하려면 먼저 웹소켓 접속 과정을 거쳐야 한다.
- 웹소켓 접속 과정은 TCP/IP 접속 그리고 웹소켓 열기 HandShake 과정으로 나눌 수 있다.
- 웹소켓도 TCP/IP위에서 동작하므로, 서버와 클라이언트는 웹소켓을 사용하기 전에 서로 TCP/IP 접속이 되어있어야 한다.
- TCP/IP 접속이 완료된 후 서버와 클라이언트는 웹소켓 열기 HandShake 과정을 시작한다.

<br/>

### 웹소켓 열기 HandShake
- 클라이언트가 먼저 HandShake 요청을 보내고 이에 대한 응답을 서버가 클라이언트로 보내는 구조이다.
- 서버와 클라이언트는 HTTP 1.1 프로토콜을 사용하여 요청과 응답을 보낸다.
- 아래는 Request와 Response의 예시이다.

<br/>

### HandShake Request
- <b> GET </b> /chatHTTP/1.1 <br>
- <b> Host </b> : server.gorany.org<br>
- <b> Upgrade </b> : websocket<br>
- <b> Connection </b> : Upgrade<br>
- <b> Sec-WebSocket-Key </b> : dGhlIACqbSBcZQBub27jWG==<br>
- <b> Origin </b> : http://localhost:8080<br>
- <b> Sec-WebSocket-Version </b> : 13 <br>

<br/>

### HandShake Response
- <b> HTTP/1.1 101 </b> SwitchingProtocols
- <b> Upgrade </b> : websocket
- <b> Connection </b> : Upgrade
- <b> Sec-WebSocket-Accept </b> : s3pPWEBhTxaQ9kYSizhZRbH+xPo=

<br><br>

## SockJS
- SpringFramework에서의 Web Socket을 활용할 때, 자바 개발자들이 socket.io를 쓸 수 없는 문제를 해결하기 위한 방법
- 자체 스팩으로 Web Socket에서 지원하지 못하는 브라우저 부분을 관리한다.
- 서버 개발 시 Spring 설정에서 일반 Web Socket으로 통신할 지 SockJS 호환으로 통신할 지 결정할 수 있으며, 클라이언트에서는 SockJS 클라이언트를 통해 서버와 통신한다.

<br>

### <b>SockJS의 구성</b>
- <b> SockJS Protocol </b> <br>
- <b> SockJS Javascript Client </b> - 브라우저에서 사용되는 클라이언트 라이브러리 <br>
- <b> SockJS Server </b> 구현 - Spring-websocket 모듈을 통해 제공 <br>
- <b> SockJS Java Client </b> - Spring-websocket 모듈을 통해 제공 (<b>Spring ver.4.1</b> ~) <br>

<br>

### SockJS의 전송 타입
<ol>
 <li> <b>WebSocket</b>
 <li> <b>HTTP Streaming</b>
 <li> <b>HTTP Long Polling</b>
</ol>
<br><br>

### SockJS Client
- SockJS Client는 서버의 기본 정보를 얻기 위해 "<b>GET/info</b>"를 호출한다.
- 서버가 WebSocket을 지원하는지, 전송 과정에서 Cookies 지원이 필요한지, 그리고 OCRS를 위한 Origin 정보 등의 정보를 응답으로 전달 받는다.
- 모든 전송 요청은 다음의 URL 구조를 갖는다.
  - https://host:prot/myApp/myEndpoint/{server-id}/{session-id}/{transport}
  - server-id : 클러스터에서 요청을 라우팅하는데 사용하나 이외에는 의미 없음
  - session-id : SockJS session에 소속하는 HTTP 요청과 연관성 있음
  - transport : 전송 타입 (예 : websocket, xhr-streaming, xhr-polling)

<br>

### SockJS Enabling
``` java
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/chat")
                .setAllowedOriginPatterns("*")
                .withSockJS();
                // webSocketConfig에서 SockJS를 가능하게 하기 위해
                // .withSockJS()를 추가해준다.
                // setAllowedOriginPatterns("*")에서 * 라는 와일드 카드를 사용하면
                // 보안상의 문제로 전체를 허용하는 것보다 직접 하나씩 지정해 주어야 한다고 한다.
    }
```
(여기 사이에 나눌 말이 들어가면 좋겠음)

```javascript
const connect = async function () {
      let socket = new SockJS("https://i6e202.p.ssafy.io:8443/chat");
      state.stompClient = Stomp.over(socket);
      await state.stompClient.connect(
        {},
        (frame) => {
          state.socketConnected = TextTrackCue;
          state.stompClient.subscribe("/send", (res) => {
            store.dispatch("root/chatRoomGetList", {
              userId: state.userInfo.id,
            });
            state.recvList.push(JSON.parse(res.body));
          });
        },
        (error) => {
          state.socketConnected = false;
        }
      );
    };
    // 프론트 쪽에서는 서버의 포트번호와 맞게 8443으로 지정해 주었다.
```

<br>

### 허용된 Origins
- Origin은 <b>Protocol, Host, Port<b> 3개 부분으로 구성된다.
- http://localhost:8080/
  - protocol : http
  - host : localhost
  - port : 8080
- <b> 3개 부분이 모두 동일한 경우만 동일한 Origin이라고 말한다. </b>
- Springframework 4.1.5를 기준으로 WebSocket 및 SockJS의 기본 동작은 동일한 Origin요청만 수락하는 것이다. 
- 모든 목록이나 특정 목록을 허용하는 것도 가능하다. 다음의 3가지 행동을 취할 수 있다.
    - <b> 동일한 오리진 요청만 허용(default) </b>
        - 이 모드에서는 SockJS가 활성화되면 iframe HTTP 응답 헤어 X-Frame-Options가 'SameOrigin'으로 설정된다. 
        - JSONP 전송은 요청의 오리진 확인이 불가능하므로 비활성화된다. 따라서 이 모드가 활성화된 경우 IE 6,7은 지원되지 않는다.
    - <b> 지정된 Origin 목록 허용</b>
        - 이 모드에서는 지정된 Origin은 반드시 http:// or https://로 시작해야 한다. 
        - 이 모드에서 SockJS가 활성화되면 iframe 전송이 비활성화되므로 IE 6~9까지는 지원되지 않는다.

    - <b> 모든 Origin 허용 </b>
        - 이 모드를 사용하면 허가된 오리진 값으로써 "*"를 사용해야 한다. 이 모드에서는 모든 전송(Send)를 사용할 수 없다.

<br/><br/>

## STOMP
- 텍스트 기반의 메세징 프로토콜이다.
- TCP나 Web Socket과 같은 신뢰성 있는 양방향 Streaming Network Protocol에서 사용 가능하다.

![채팅시스템_STOMP](./screenshot/채팅시스템_STOMP.PNG)

- STOMP는 구독이라는 개념을 통해 내가 통신하고자 하는 주체를 판단하여 브로커라는 개념을 두어 실시간으로 계속 관심을 가지며 아래와 같은 요청들을 처리하게 된다.

<br/>

### Connect

![채팅시스템_STOMP1](./screenshot/채팅시스템_STOMP1.PNG)

- 연결에 관한 구조
- **버전 정보**와 현재의 세션 정보를 가져온다.

<br/>

### Subscribe

![채팅시스템_STOMP2](./screenshot/채팅시스템_STOMP2.PNG)

- 구독이라는 개념을 이용해 현재 메세지에 대한 목적지를 설정한다.

- Connect 이후에 Subscribe를 설정하게 된다.
- 등록되지 않은 Subscribe를 호출 시 찾을 수 없기에 정확한 통신이 되지 않는다.

<br/>

### Message

![채팅시스템_STOMP3](./screenshot/채팅시스템_STOMP3.PNG)

- 메세지를 전송할 때의 구조이다.
- 메세지의 전달지와 해당 메세지의 정보들이 출력된다.
- 다양한 데이터 타입을 가질 수 있다.

<br/>

### Disconnect

![채팅시스템_STOMP4](./screenshot/채팅시스템_STOMP4.PNG)

- 연결을 종료했을 때의 구조이다.
- 통신 상태에 따라서 정해진 구조를 가지고 통신을 하게 된다.


<br/><br/><br/>


# S3(Simple Storage Service)
- AWS에서 제공하는 객체 스토리지 서비스
 
- 서비스 과정에서 사용되는 프로필 이미지 파일들을 업로드 하여 관리하기 위해서 사용

<br/>

### 1. AWS S3 bucket 생성
``` yml
  1. [AWS -> S3 -> 버킷 만들기]에서 새로운 버킷을 만든다.
  2. 퍼블릭 액세스를 허용해준다.
  3. 권한 -> 버킷 정책으로 들어가서 정책을 설정한다.
  
  {
      "Version": "2012-10-17",
      "Id": "Policy1644805559372",
      "Statement": [
          {
              "Sid": "Stmt1644805556206",
              "Effect": "Allow",
              "Principal": "*",
              "Action": [
                  "s3:GetObject",
                  "s3:PutObject"
              ],
              "Resource": "arn:aws:s3:::[버킷 이름]/*"
          }
      ]
  } 
```

<br/>

### 2. AWS IAM 사용자 생성
```Text
  AWS 액세스 유형 : 프로그래밍 방식 액세스

  권한 설정 : AmazonS3FullAccess 선택

  AccessKey와 Secret Key 저장
```

<br/>

### 3.  build.gradle에 의존성 추가
```gradle
  implementation("io.awspring.cloud:spring-cloud-aws-context:2.3.3")

  implementation("org.springframework.cloud:spring-cloud-aws-autoconfigure:2.2.6.RELEASE")
```

<br/>

### 4. s3 config 파일 추가
```java
  public AmazonS3Client amazonS3Client() {
      BasicAWSCredentials awsCreds = new BasicAWSCredentials(accessKey, secretKey);
      
      return (AmazonS3Client) AmazonS3ClientBuilder.standard()
              .withRegion(region)
              .withCredentials(new AWSStaticCredentialsProvider(awsCreds))
              .build();
  }
```

<br/>

### 5. S3 service 클래스 추가

```java
  public String upload(MultipartFile uploadFile) throws IOException { ... }

  public void deleteFile(String fileName) { ... }

  private static String getUuid() { ... }

  private void uploadOnS3(final String findName, final File file) { ... }

  public String findImg(String img) { ... }

```